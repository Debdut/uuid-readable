{"version":3,"file":"index.umd.min.js","sources":["../data/name/index.ts","../data/grammer/index.ts","../data/animal/index.ts","../src/util.ts","../src/schema.ts","../src/readable.ts","../src/low-entropy.ts","../src/index.ts"],"sourcesContent":["import * as First from \"./first.json\";\nimport * as Last from \"./last.json\";\nimport * as Middle from \"./middle.json\";\n\nexport default { First, Last, Middle };\n","import * as Adjective from \"./adjective.json\";\nimport * as Adverb from \"./adverb.json\";\nimport * as Verb from \"./verb.json\";\nimport * as PersonalNoun from \"./personal-noun.json\";\n\nexport default { Adjective, Adverb, Verb, PersonalNoun };\n","import * as Noun from \"./noun.json\";\nimport * as Adjective from \"./adjective.json\";\nimport * as Verb from \"./verb.json\";\n\nexport default { Noun, Adjective, Verb };\n","const caps = (w: string) => w.charAt(0).toUpperCase() + w.slice(1);\nconst deCaps = (w: string) => w.toLowerCase();\n\nconst toBits = (byte: number, length = 8) => {\n  const bits = [];\n  for (let i = 0; i < length; i++) {\n    bits.unshift(byte % 2);\n    byte = byte >> 1;\n  }\n\n  return bits;\n};\n\nconst toByte = (bits: number[]) => {\n  let byte = 0;\n  for (let i = 0; i < bits.length; i++) {\n    const bit = bits[i] as number;\n    byte = 2 * byte + bit;\n  }\n  return byte;\n};\n\nexport default { caps, deCaps, toBits, toByte };\n","import Name from \"../data/name\";\nimport Grammer from \"../data/grammer\";\nimport Place from \"../data/place\";\nimport Animal from \"../data/animal\";\n\nimport _ from \"./util.js\";\n\nclass Element<T> {\n  length: number;\n  generate: (a: number) => T;\n  inv: (a: T) => number;\n  bit: number;\n  constructor(\n    length: number,\n    generate: (a: number) => T,\n    inv: (a: T) => number\n  ) {\n    (this.length = length), (this.generate = generate);\n    this.inv = inv;\n\n    this.bit = Math.trunc(Math.log2(this.length));\n  }\n\n  inverse(val: T) {\n    const byte = this.inv(val);\n    if (byte === -1) {\n      return -1;\n    }\n\n    return _.toBits(byte, this.bit);\n  }\n}\n\nconst Count = (n: number) =>\n  new Element<number>(\n    n,\n    (i: number) => i + 2,\n    (i: number) => (i > 1 && i < 34 ? i - 2 : -1)\n  );\n\nconst List = (list: string[]) =>\n  new Element<string>(\n    list.length,\n    (i: number) => list[i % list.length] as string,\n    (word: string) => list.indexOf(word)\n  );\n\nconst Full = [\n  List(Name.First),\n  List(Name.Middle),\n  List(Name.Last),\n  List(Grammer.PersonalNoun),\n  List(Place),\n  List(Grammer.Verb),\n  List(Name.First),\n  List(Name.Middle),\n  List(Name.Last),\n  Count(32),\n  List(Animal.Adjective),\n  List(Animal.Noun),\n];\n\nconst LowEntropy = [\n  Count(64),\n  List(Animal.Adjective),\n  List(Animal.Noun),\n  List(Grammer.Adverb),\n  List(Animal.Verb),\n];\n\nexport default { Full, LowEntropy };\n","import Schema from \"./schema\";\nimport _ from \"./util\";\n\nconst partition = (parts: number[], bytes: number[]) => {\n  let bits = Array.from(bytes)\n    .map((byte) => _.toBits(byte))\n    .reduce((a, c) => a.concat(c), []);\n  const _bytes = [];\n\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i] as number;\n    const temp = bits.splice(part);\n    const part_bits = bits;\n    bits = temp;\n    const byte = _.toByte(part_bits);\n    _bytes.push(byte);\n  }\n\n  return _bytes;\n};\n\nconst dePartition = (bitsList: number[][]) => {\n  const bits = bitsList.reduce((a, c) => a.concat(c), []);\n\n  const bytes = [];\n\n  for (let i = 0; i < 16; i++) {\n    const part = bits.slice(8 * i, 8 * (i + 1));\n    const byte = _.toByte(part);\n    bytes.push(byte);\n  }\n\n  return bytes;\n};\n\nconst sentence = (w: (string | number | undefined)[]) =>\n  `${w[0]} ${w[1]} ${w[2]} the ${_.caps(`${w[3]}`)} of ${w[4]} ${w[5]} ${\n    w[6]\n  } ${w[7]} ${w[8]} and ${w[9]} ${w[10]} ${w[11]}`;\nconst deSentence = (s: string) => {\n  let rest = s.split(\" the \") as string[];\n\n  const p1 = (rest[0] as string).trim().split(\" \");\n\n  rest = (rest[1] as string).split(\" of \");\n  const p2 = (rest[0] as string).trim().split(\" \");\n\n  rest = (rest[1] as string).split(\" and \");\n  const p3 = (rest[0] as string).trim().split(\" \");\n  const p4 = (rest[1] as string).trim().split(\" \");\n\n  const w = [\n    p1[0],\n    p1[1],\n    p1[2],\n    _.deCaps(p2[0] || \"\"),\n    p3[0],\n    p3[1],\n    p3[2],\n    p3[3],\n    p3[4],\n    parseInt(p4[0] || \"\", 10),\n    p4[1],\n    p4[2],\n  ];\n\n  return w;\n};\n\nconst valid = () => {\n  return Schema.Full.map((s) => s.bit).reduce((a, c) => a + c) === 128;\n};\n\n// Parts\n// [\n//   12, 11, 14, 13, 13,\n//   10, 12, 11, 14,  5,\n//    6,  7\n// ]\n\nconst generate = (uuid: number[]) => {\n  const parts = Schema.Full.map((s) => s.bit);\n  const words = partition(parts, uuid).map((b, i) =>\n    Schema.Full[i]?.generate(b)\n  );\n  return sentence(words);\n};\n\nconst inverse = (readable: string) => {\n  const bits = deSentence(readable).map((w, i) =>\n    Schema.Full[i]?.inverse(w as never)\n  );\n\n  // Check -1 in words\n  if (bits.indexOf(-1) >= 0) {\n    throw new Error(\"Not A Valid UUID Readable\");\n  }\n\n  // dePartition\n  const bytes = dePartition(bits as number[][]);\n\n  return bytes;\n};\n\nexport default { generate, inverse, valid };\n","import Schema from \"./schema.js\";\nimport _ from \"./util.js\";\n\nconst partition = (parts: number[], bytes: number[]) => {\n  let bits = Array.from(bytes)\n    .map((byte) => _.toBits(byte))\n    .map((bits) => bits.slice(0, 2))\n    .reduce((a, c) => a.concat(c), []);\n  const _bytes = [];\n\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i] as number;\n    const temp = bits.splice(part);\n    const part_bits = bits;\n    bits = temp;\n    const byte = _.toByte(part_bits);\n    _bytes.push(byte);\n  }\n\n  return _bytes;\n};\n\nconst sentence = (w: (string | number | undefined)[]) =>\n  `${w[0]} ${w[1]} ${w[2]} ${w[3]} ${w[4]}`;\nconst deSentence = (s: string) => {\n  const w = s.trim().split(\" \");\n\n  return [parseInt(w[0] as string, 10), w[1], w[2], w[3], w[4]];\n};\n\nconst generate = (uuid: number[]) => {\n  const parts = Schema.LowEntropy.map((s) => s.bit);\n\n  const words = partition(parts, uuid).map((b, i) =>\n    Schema.LowEntropy[i]?.generate(b)\n  );\n\n  return sentence(words);\n};\n\nconst check = (readable: string, uuid: number[]) => {\n  const uuidBits = Array.from(uuid)\n    .map((byte) => _.toBits(byte))\n    .map((bits) => bits.slice(0, 2))\n    .reduce((a, c) => a.concat(c), []);\n\n  const readableBits = deSentence(readable).map((w, i) =>\n    Schema.LowEntropy[i]?.inverse(w as never)\n  );\n\n  if (readableBits.indexOf(-1) >= 0) {\n    return false;\n  }\n\n  const readableBitsReduced = readableBits.reduce(\n    (a, c) => (a as number[]).concat(c as number[]),\n    []\n  );\n\n  for (let i = 0; i < uuidBits.length; i++) {\n    // @ts-ignore\n    if (uuidBits[i] !== readableBitsReduced[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport default { generate, check };\n","import * as UUID from \"uuid\";\nimport Readable from \"./readable\";\nimport LowEntropy from \"./low-entropy\";\n\n// Generate a uuid readable.\nexport const generate = (uuid: string) => {\n  if (!uuid) {\n    const _uuid: number[] = [];\n    UUID.v4({}, _uuid);\n\n    return Readable.generate(_uuid);\n  }\n\n  return Readable.generate(UUID.parse(uuid) as number[]);\n};\n\n// Get uuid back from readable.\nexport const inverse = (readable: string) => {\n  return UUID.stringify(Readable.inverse(readable));\n};\n\n// Create a low entropy 32 bit uuid readable.\nexport const short = (uuid: string) => {\n  return LowEntropy.generate(UUID.parse(uuid) as number[]);\n};\n\n// Check if the low entropy uuid is generated from the given uuid.\nexport const check = (readable: string, uuid: string) => {\n  return LowEntropy.check(readable, UUID.parse(uuid) as number[]);\n};\n"],"names":["Name","First","Last","Middle","Grammer","Adjective","Adverb","Verb","PersonalNoun","Animal","Noun","_","w","charAt","toUpperCase","slice","toLowerCase","byte","length","bits","i","unshift","Element","generate","inv","this","bit","Math","trunc","log2","prototype","inverse","val","Count","n","List","list","word","indexOf","Schema","Full","Place","LowEntropy","Readable","uuid","words","parts","bytes","Array","from","map","reduce","a","c","concat","_bytes","part","temp","splice","part_bits","push","partition","s","b","_a","readable","rest","p1","p2","p3","p4","split","trim","parseInt","Error","bitsList","dePartition","uuidBits","readableBits","readableBitsReduced","UUID","parse","_uuid","v4","stringify"],"mappings":"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"}